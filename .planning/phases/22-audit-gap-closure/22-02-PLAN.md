---
phase: 22-audit-gap-closure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/admin/pricing/page.tsx
autonomous: true

must_haves:
  truths:
    - "Admin pricing page shows a table of all active services"
    - "Each service row has a three-dot (⋮) menu with Modifier, Exporter, and Supprimer options"
    - "Modifier opens inline editing for the service row"
    - "Exporter downloads service data as CSV"
    - "Supprimer soft-deletes the service (with usage check)"
  artifacts:
    - path: "src/app/admin/pricing/page.tsx"
      provides: "Service table with three-dot context menu"
      contains: "DropdownMenu"
  key_links:
    - from: "src/app/admin/pricing/page.tsx"
      to: "/api/admin/services"
      via: "fetch calls for GET, PUT, DELETE"
      pattern: "fetch.*admin/services"
---

<objective>
Add a service listing table with three-dot context menu to the admin pricing page.

Purpose: Client requested "trois petits points... modifier... exporter... delete" on service rows (AUTOMATO NEW-011). The admin pricing page currently only has import functionality. This adds a service management table below the import section with DropdownMenu actions on each row.

Output: Admin pricing page shows all active services in a table, each with a ⋮ menu offering Modifier (inline edit), Exporter (CSV download), and Supprimer (soft delete with usage check).
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/app/admin/pricing/page.tsx
@src/app/api/admin/services/route.ts
@src/app/board/page.tsx (lines 402-434 for DropdownMenu pattern)
@src/components/ui/dropdown-menu.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add service listing table with three-dot menu to admin pricing page</name>
  <files>src/app/admin/pricing/page.tsx</files>
  <action>
  Enhance src/app/admin/pricing/page.tsx to include a service management table below the existing import section.

  **1. Add imports at the top:**
  ```tsx
  import { useEffect } from 'react';  // add useEffect to existing useState import
  import {
    DropdownMenu,
    DropdownMenuTrigger,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuSeparator,
  } from '@/components/ui/dropdown-menu';
  import { MoreHorizontal, Edit, Download as DownloadIcon, Trash2 } from 'lucide-react';
  ```
  Note: Download is already imported from lucide-react — rename one to DownloadIcon to avoid conflict.

  **2. Add state variables after existing state:**
  ```tsx
  // Service management state
  interface ServiceRow {
    id: string;
    code: string;
    name: string;
    category: string | null;
    base_price_cents: number;
    estimated_minutes: number;
    is_active: boolean;
    is_custom: boolean;
  }
  const [servicesList, setServicesList] = useState<ServiceRow[]>([]);
  const [loadingServices, setLoadingServices] = useState(true);
  const [editingService, setEditingService] = useState<string | null>(null);
  const [editForm, setEditForm] = useState({ name: '', price: '', category: '', estimated_minutes: '' });
  const [deletingService, setDeletingService] = useState<string | null>(null);
  ```

  **3. Add data fetching function and useEffect:**
  ```tsx
  const fetchServices = async () => {
    setLoadingServices(true);
    try {
      const response = await fetch('/api/admin/services');
      if (response.ok) {
        const data = await response.json();
        setServicesList(data.services || []);
      }
    } catch (error) {
      console.error('Error fetching services:', error);
    } finally {
      setLoadingServices(false);
    }
  };

  useEffect(() => {
    fetchServices();
  }, []);
  ```

  **4. Add handler functions:**
  ```tsx
  const handleStartEdit = (service: ServiceRow) => {
    setEditingService(service.id);
    setEditForm({
      name: service.name,
      price: (service.base_price_cents / 100).toFixed(2),
      category: service.category || '',
      estimated_minutes: String(service.estimated_minutes || 15),
    });
  };

  const handleSaveEdit = async (serviceId: string) => {
    try {
      const response = await fetch('/api/admin/services', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: serviceId,
          name: editForm.name,
          price: parseFloat(editForm.price),
          category: editForm.category || null,
          estimated_minutes: parseInt(editForm.estimated_minutes) || 15,
        }),
      });
      if (response.ok) {
        setEditingService(null);
        await fetchServices();
      } else {
        const data = await response.json();
        alert(data.error || 'Failed to update service');
      }
    } catch (error) {
      console.error('Error updating service:', error);
      alert('Failed to update service');
    }
  };

  const handleExportService = (service: ServiceRow) => {
    const csvContent = [
      'Name,Category,Price,Minutes,Code',
      `"${service.name}","${service.category || ''}",${(service.base_price_cents / 100).toFixed(2)},${service.estimated_minutes},"${service.code}"`,
    ].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `service-${service.code}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const handleDeleteService = async (serviceId: string) => {
    setDeletingService(serviceId);
    try {
      // Check usage first
      const usageRes = await fetch(`/api/admin/services?id=${serviceId}&usage=true`);
      const usageData = await usageRes.json();
      if (!usageData.canDelete) {
        alert(`Ce service est utilise dans ${usageData.usageCount} commande(s). Retirez-le des commandes avant de supprimer.`);
        return;
      }
      const response = await fetch(`/api/admin/services?id=${serviceId}`, { method: 'DELETE' });
      if (response.ok) {
        await fetchServices();
      } else {
        const data = await response.json();
        alert(data.error || 'Failed to delete service');
      }
    } catch (error) {
      console.error('Error deleting service:', error);
      alert('Failed to delete service');
    } finally {
      setDeletingService(null);
    }
  };
  ```

  **5. Add service table section in the JSX, AFTER the Instructions Card (after the closing `</Card>` tag around line 335), but still inside the scrollable container:**

  ```tsx
  {/* Service Management Table */}
  <Card className='mt-6'>
    <CardHeader>
      <CardTitle>Services</CardTitle>
      <CardDescription>Gerer les services et les prix</CardDescription>
    </CardHeader>
    <CardContent>
      {loadingServices ? (
        <div className='text-center py-8 text-muted-foreground'>
          <RefreshCw className='w-8 h-8 mx-auto mb-2 animate-spin' />
          <p>Chargement des services...</p>
        </div>
      ) : servicesList.length === 0 ? (
        <div className='text-center py-8 text-muted-foreground'>
          <p>Aucun service trouve. Importez des donnees ci-dessus.</p>
        </div>
      ) : (
        <div className='overflow-x-auto'>
          <table className='w-full text-sm'>
            <thead>
              <tr className='border-b border-border'>
                <th className='text-left py-2 px-3 font-medium'>Nom</th>
                <th className='text-left py-2 px-3 font-medium'>Categorie</th>
                <th className='text-right py-2 px-3 font-medium'>Prix</th>
                <th className='text-right py-2 px-3 font-medium'>Minutes</th>
                <th className='w-10 py-2 px-3'></th>
              </tr>
            </thead>
            <tbody>
              {servicesList.map(service => (
                <tr key={service.id} className='border-b border-border/50 hover:bg-muted/50'>
                  {editingService === service.id ? (
                    <>
                      <td className='py-2 px-3'>
                        <input
                          type='text'
                          value={editForm.name}
                          onChange={e => setEditForm(f => ({ ...f, name: e.target.value }))}
                          className='w-full px-2 py-1 border border-border rounded text-sm'
                        />
                      </td>
                      <td className='py-2 px-3'>
                        <input
                          type='text'
                          value={editForm.category}
                          onChange={e => setEditForm(f => ({ ...f, category: e.target.value }))}
                          className='w-full px-2 py-1 border border-border rounded text-sm'
                        />
                      </td>
                      <td className='py-2 px-3 text-right'>
                        <input
                          type='number'
                          step='0.01'
                          value={editForm.price}
                          onChange={e => setEditForm(f => ({ ...f, price: e.target.value }))}
                          className='w-20 px-2 py-1 border border-border rounded text-sm text-right'
                        />
                      </td>
                      <td className='py-2 px-3 text-right'>
                        <input
                          type='number'
                          value={editForm.estimated_minutes}
                          onChange={e => setEditForm(f => ({ ...f, estimated_minutes: e.target.value }))}
                          className='w-16 px-2 py-1 border border-border rounded text-sm text-right'
                        />
                      </td>
                      <td className='py-2 px-3'>
                        <div className='flex gap-1'>
                          <Button size='sm' variant='ghost' onClick={() => handleSaveEdit(service.id)} className='h-8 px-2 text-xs'>
                            OK
                          </Button>
                          <Button size='sm' variant='ghost' onClick={() => setEditingService(null)} className='h-8 px-2 text-xs'>
                            X
                          </Button>
                        </div>
                      </td>
                    </>
                  ) : (
                    <>
                      <td className='py-2 px-3 font-medium'>{service.name}</td>
                      <td className='py-2 px-3 text-muted-foreground capitalize'>{service.category || '—'}</td>
                      <td className='py-2 px-3 text-right'>{(service.base_price_cents / 100).toFixed(2)} $</td>
                      <td className='py-2 px-3 text-right'>{service.estimated_minutes} min</td>
                      <td className='py-2 px-3'>
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button variant='ghost' size='sm' className='h-8 w-8 p-0'>
                              <MoreHorizontal className='h-4 w-4' />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align='end'>
                            <DropdownMenuItem onClick={() => handleStartEdit(service)}>
                              <Edit className='w-4 h-4 mr-2' />
                              Modifier
                            </DropdownMenuItem>
                            <DropdownMenuItem onClick={() => handleExportService(service)}>
                              <DownloadIcon className='w-4 h-4 mr-2' />
                              Exporter
                            </DropdownMenuItem>
                            <DropdownMenuSeparator />
                            <DropdownMenuItem
                              onClick={() => handleDeleteService(service.id)}
                              className='text-red-600'
                              disabled={deletingService === service.id}
                            >
                              <Trash2 className='w-4 h-4 mr-2' />
                              Supprimer
                            </DropdownMenuItem>
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </td>
                    </>
                  )}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </CardContent>
  </Card>
  ```

  **6. Refresh services after import succeeds.** In the handleImport function, after `setImportResult(result)` inside the try block, add:
  ```tsx
  if (result.success) {
    await fetchServices();
  }
  ```

  **Important notes:**
  - Follow the existing DropdownMenu pattern from board/page.tsx (lines 402-434)
  - Use French labels: "Modifier", "Exporter", "Supprimer"
  - Soft delete via API (sets is_active = false)
  - Check usage before delete (API already supports this)
  - Inline editing replaces row content with input fields
  - Resolve the `Download` import name conflict with existing lucide icon
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles clean. Grep for "DropdownMenu" in admin/pricing/page.tsx to confirm presence. Grep for "Modifier" to confirm French labels.</verify>
  <done>Admin pricing page shows service table with three-dot menu. Each row has Modifier (inline edit), Exporter (CSV download), and Supprimer (soft delete with usage check). Services refresh after import. TypeScript compiles clean.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `grep -n "DropdownMenu" src/app/admin/pricing/page.tsx` shows dropdown menu usage
3. `grep -n "Modifier" src/app/admin/pricing/page.tsx` shows French label
4. `grep -n "Exporter" src/app/admin/pricing/page.tsx` shows French label
5. `grep -n "Supprimer" src/app/admin/pricing/page.tsx` shows French label
6. `grep -n "fetchServices" src/app/admin/pricing/page.tsx` shows data fetching
</verification>

<success_criteria>
- Admin pricing page loads and displays all active services in a table
- Each service row shows name, category, price, and estimated minutes
- Three-dot (⋮) button on each row opens dropdown with Modifier, Exporter, Supprimer
- Modifier switches row to inline edit mode with OK/X buttons
- Exporter downloads single-service CSV file
- Supprimer checks usage and soft-deletes if no garments use it
- Services list refreshes after successful import
- TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/22-audit-gap-closure/22-02-SUMMARY.md`
</output>
