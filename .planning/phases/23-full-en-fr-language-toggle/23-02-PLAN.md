---
phase: 23-full-en-fr-language-toggle
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - locales/en.json
  - locales/fr.json
autonomous: true

must_haves:
  truths:
    - "en.json and fr.json have identical key structures"
    - "Every hardcoded string identified in audit has a corresponding translation key"
    - "Translation keys cover all 25 pages and 67 components"
    - "Board, intake, admin, auth, clients, dashboard, payments, and common sections all have translation keys"
  artifacts:
    - path: "locales/en.json"
      provides: "Complete English translations"
      min_lines: 400
    - path: "locales/fr.json"
      provides: "Complete French translations"
      min_lines: 400
  key_links:
    - from: "locales/en.json"
      to: "locales/fr.json"
      via: "Identical key structure"
      pattern: "Same nested JSON keys in both files"
---

<objective>
Expand both locale JSON files with all missing translation keys identified in the hardcoded string audit. This covers every section of the application: board, intake wizard, admin pages, client pages, auth, dashboard, payments, common UI elements, toasts, error messages, and validation text.

Purpose: Translation files must be complete BEFORE components can be migrated. Components reference these keys via t('key.path'), so all keys must exist in both files first.

Output: Complete en.json and fr.json with ~400+ keys each, covering every user-facing string in the application.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-full-en-fr-language-toggle/23-RESEARCH.md

@locales/en.json
@locales/fr.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit existing keys and identify all missing translations</name>
  <files>
    locales/en.json
    locales/fr.json
  </files>
  <action>
    1. Read both locales/en.json and locales/fr.json to understand the existing 234-key structure
    2. Grep across ALL .tsx files for hardcoded French and English strings. Use these search patterns:
       ```bash
       # Find French hardcoded strings
       grep -rn "Chargement\|Réessayer\|Aucun\|Retour\|Commande\|Tableau\|Nouvelle\|Charge de\|Archivees\|Non assigne\|Article ajouté\|Couturière\|Gestionnaire\|Administrateur\|Sauvegarder\|Supprimer\|Modifier\|Exporter\|Ajouter\|Fermer\|Annuler\|Confirmer\|Enregistrer" src/ --include="*.tsx"

       # Find English hardcoded strings
       grep -rn '"Loading\|"Try Again\|"Unassigned\|"Delete\|"Export\|"Cancel\|"Save\|"Close\|"Board\|"List\|"Home\|"Profile\|"Orders\|"Analytics\|"Check your email\|"Choose how\|"Some items\|"Cannot mark\|"Unable to load\|"Export failed\|"Network error" src/ --include="*.tsx"
       ```
    3. Cross-reference audit results with the "Complete Hardcoded String Audit" in 23-RESEARCH.md
    4. Build a complete list of ALL required translation keys organized by namespace

    This task produces the complete key inventory. Task 2 writes the files.
  </action>
  <verify>
    - Audit covers all 30 files listed in research
    - Every hardcoded string from 23-RESEARCH.md has a corresponding key identified
    - Key namespaces are organized logically (board, intake, admin, clients, common, etc.)
  </verify>
  <done>
    Complete inventory of all required translation keys with EN and FR values, organized by namespace, covering all 30+ files from audit
  </done>
</task>

<task type="auto">
  <name>Task 2: Expand en.json and fr.json with all missing keys</name>
  <files>
    locales/en.json
    locales/fr.json
  </files>
  <action>
    Using the key inventory from Task 1, expand both JSON files.

    PRESERVE all existing 234 keys exactly as they are. ADD new sections/keys.

    Required new sections and keys (add to both files with appropriate EN/FR values):

    **common section additions:**
    ```
    common.loading: "Loading..." / "Chargement..."
    common.tryAgain: "Try Again" / "Réessayer"
    common.error: "Error" / "Erreur"
    common.save: "Save" / "Sauvegarder"
    common.cancel: "Cancel" / "Annuler"
    common.close: "Close" / "Fermer"
    common.delete: "Delete" / "Supprimer"
    common.edit: "Edit" / "Modifier"
    common.export: "Export" / "Exporter"
    common.add: "Add" / "Ajouter"
    common.confirm: "Confirm" / "Confirmer"
    common.none: "None" / "Aucun"
    common.all: "All" / "Tous"
    common.back: "Back" / "Retour"
    common.search: "Search" / "Rechercher"
    common.filter: "Filter" / "Filtrer"
    common.noResults: "No results" / "Aucun résultat"
    common.required: "Required" / "Requis"
    common.optional: "Optional" / "Optionnel"
    common.home: "Home" / "Accueil"
    ```

    **board section (add/expand):**
    ```
    board.title: "Production Board" / "Tableau de Production"
    board.viewModes.board: "Board" / "Tableau"
    board.viewModes.list: "List" / "Liste"
    board.menu.workload: "Workload" / "Charge de Travail"
    board.menu.archived: "Archived Orders" / "Commandes Archivées"
    board.menu.exportOrders: "Export Orders" / "Exporter Commandes"
    board.menu.exportCapacity: "Export Capacity" / "Exporter Capacité"
    board.actions.newOrder: "New Order" / "Nouvelle Commande"
    board.actions.exportWorkList: "Export Work List" / "Exporter Liste de Travail"
    board.errors.loadFailed: "Unable to load orders" / "Impossible de charger les commandes"
    board.errors.exportFailed: "Export failed" / "Échec de l'export"
    board.errors.networkError: "Export failed: Network error" / "Échec de l'export: Erreur réseau"
    board.errors.workTimeRequired: "Cannot mark as done: Please record work hours first." / "Impossible de terminer: Veuillez d'abord enregistrer les heures de travail."
    board.success.exported: "Exported tasks for {name}" / "Tâches exportées pour {name}"
    board.success.ordersExported: "Orders exported" / "Commandes exportées"
    board.success.capacityExported: "Capacity exported" / "Capacité exportée"
    board.columns.pending: "Pending" / "En Attente"
    board.columns.working: "Working" / "En Cours"
    board.columns.done: "Done" / "Terminé"
    board.columns.ready: "Ready" / "Prêt"
    board.columns.delivered: "Delivered" / "Livré"
    board.columns.descriptions.pending: "New orders awaiting assignment" / "Nouvelles commandes en attente d'assignation"
    board.columns.descriptions.working: "Orders currently in progress" / "Commandes en cours de réalisation"
    board.columns.descriptions.done: "Completed work awaiting review" / "Travaux terminés en attente de révision"
    board.columns.descriptions.ready: "Ready for pickup or delivery" / "Prêt pour le ramassage ou la livraison"
    board.columns.descriptions.delivered: "Completed and delivered" / "Terminé et livré"
    board.card.orderNumber: "Order #" / "Commande #"
    board.card.dueDate: "Due Date" / "Date d'Échéance"
    board.card.assignee: "Assigned to" / "Assigné à"
    board.card.noAssignee: "Unassigned" / "Non Assigné"
    board.card.someUnassigned: "Some items unassigned" / "Certains articles non assignés"
    board.card.unassignedItems: "Unassigned items" / "Articles non assignés"
    board.filter.unassigned: "Unassigned" / "Non Assigné"
    board.today.all: "All" / "Tous"
    ```

    **intake section (add/expand):**
    ```
    intake.services.itemAdded: "Item added to order" / "Article ajouté à la commande"
    intake.services.timeRequired: "Time estimate is required" / "Le temps estimé est requis"
    intake.services.addToOrder: "Add to Order" / "Ajouter à la Commande"
    intake.garments.delete: "Delete" / "Supprimer"
    intake.assignment.unassigned: "Unassigned" / "Non Assigné"
    ```

    **categories section (new):**
    ```
    categories.other: "Other" / "Autre"
    categories.home: "Home" / "Maison"
    categories.outdoor: "Outdoor" / "Extérieur"
    categories.womens: "Women's" / "Femmes"
    categories.mens: "Men's" / "Hommes"
    categories.outerwear: "Outerwear" / "Manteaux"
    categories.formal: "Formal" / "Formel"
    categories.activewear: "Activewear" / "Sport"
    ```

    **admin section (new):**
    ```
    admin.team.title: "Team Management" / "Gestion d'Équipe"
    admin.team.role: "Role" / "Rôle"
    admin.pricing.title: "Services" / "Services"
    admin.pricing.description: "Manage services and pricing" / "Gérer les services et les prix"
    admin.pricing.headers.name: "Name" / "Nom"
    admin.pricing.headers.category: "Category" / "Catégorie"
    admin.pricing.headers.price: "Price" / "Prix"
    admin.pricing.headers.description: "Description" / "Description"
    admin.pricing.headers.minutes: "Minutes" / "Minutes"
    admin.pricing.headers.icon: "Icon" / "Icône"
    admin.measurements.retry: "Try Again" / "Réessayer"
    admin.measurements.noFields: "No measurement fields in this category" / "Aucun champ de mesure dans cette catégorie"
    ```

    **clients section (new):**
    ```
    clients.backToList: "Back to Clients" / "Retour aux clients"
    clients.noOrders: "No orders" / "Aucune commande"
    clients.noMeasurements: "No recorded measurements" / "Aucune mesure enregistrée"
    clients.orderNumber: "Order #{number}" / "Commande #{number}"
    ```

    **dashboard section (new):**
    ```
    dashboard.profile: "Profile" / "Profil"
    dashboard.orders: "Orders" / "Commandes"
    dashboard.analytics: "Analytics" / "Analyses"
    ```

    **auth section (new):**
    ```
    auth.checkEmail: "Check your email" / "Vérifiez votre courriel"
    ```

    **payments section (new):**
    ```
    payments.chooseAmount: "Choose how much to pay now" / "Choisissez le montant à payer maintenant"
    ```

    **roles section (new):**
    ```
    roles.label: "Role" / "Rôle"
    roles.seamstress: "Seamstress" / "Couturière"
    roles.manager: "Manager" / "Gestionnaire"
    roles.admin: "Administrator" / "Administrateur"
    ```

    **statuses section (new):**
    ```
    statuses.pending: "Pending" / "En Attente"
    statuses.working: "Working" / "En Cours"
    statuses.done: "Done" / "Terminé"
    statuses.ready: "Ready" / "Prêt"
    statuses.delivered: "Delivered" / "Livré"
    ```

    **booking section (add/expand to replace inline translations):**
    Read src/app/booking/page.tsx lines 18-48 to capture all inline translation keys, then add them to the locale files under a `booking` namespace.

    IMPORTANT: Also read EVERY file from the 30-file list in the research to identify ANY additional hardcoded strings not captured above. The audit in the research is thorough but there may be strings inside conditional logic, error handling, or dynamic content that need keys.

    After writing both files, validate:
    ```bash
    # Check both files are valid JSON
    node -e "JSON.parse(require('fs').readFileSync('locales/en.json','utf8')); console.log('en.json valid')"
    node -e "JSON.parse(require('fs').readFileSync('locales/fr.json','utf8')); console.log('fr.json valid')"

    # Check key counts match
    node -e "const en=Object.keys(JSON.stringify(JSON.parse(require('fs').readFileSync('locales/en.json','utf8')))).length; const fr=Object.keys(JSON.stringify(JSON.parse(require('fs').readFileSync('locales/fr.json','utf8')))).length; console.log('en keys:', en, 'fr keys:', fr, 'match:', en===fr)"
    ```

    CRITICAL: Both files MUST have identical key structures. Every key in en.json must exist in fr.json and vice versa. The values are different (English vs French) but the structure must be a mirror.
  </action>
  <verify>
    - Both en.json and fr.json parse as valid JSON
    - Both files have identical key structures (same nested paths)
    - Key count is 400+ in each file (234 existing + ~200 new)
    - All sections from the list above exist in both files
    - No hardcoded strings from 23-RESEARCH.md audit are missing
    - Run deep key comparison to catch mismatches between en.json and fr.json:
      ```bash
      node -e "
        const en = JSON.parse(require('fs').readFileSync('locales/en.json','utf8'));
        const fr = JSON.parse(require('fs').readFileSync('locales/fr.json','utf8'));
        function getKeys(obj, prefix='') {
          return Object.entries(obj).flatMap(([k,v]) =>
            typeof v === 'object' && v !== null ? getKeys(v, prefix+k+'.') : [prefix+k]
          );
        }
        const enKeys = new Set(getKeys(en));
        const frKeys = new Set(getKeys(fr));
        const missingInFr = [...enKeys].filter(k => !frKeys.has(k));
        const missingInEn = [...frKeys].filter(k => !enKeys.has(k));
        if (missingInFr.length) { console.error('FAIL - Missing in fr.json:', missingInFr); process.exit(1); }
        if (missingInEn.length) { console.error('FAIL - Missing in en.json:', missingInEn); process.exit(1); }
        console.log('PASS - Keys in sync! Total:', enKeys.size);
      "
      ```
      This MUST output "PASS - Keys in sync!" with zero missing keys. If it fails, fix all mismatches before proceeding.
  </verify>
  <done>
    en.json and fr.json both contain 400+ translation keys with identical key structures, covering all board, intake, admin, client, auth, dashboard, payment, category, role, status, and common UI strings
  </done>
</task>

</tasks>

<verification>
1. `node -e "JSON.parse(require('fs').readFileSync('locales/en.json','utf8')); console.log('OK')"` succeeds
2. `node -e "JSON.parse(require('fs').readFileSync('locales/fr.json','utf8')); console.log('OK')"` succeeds
3. Key structure comparison shows identical keys in both files
4. grep for any section name (board, intake, admin, etc.) returns matches in both files
</verification>

<success_criteria>
- Both JSON files are valid and parseable
- Both have identical key structure (mirror keys, different values)
- All sections identified in research audit have corresponding keys
- 400+ keys in each file (comprehensive coverage)
- Keys follow nested namespace pattern (board.card.orderNumber, not boardCardOrderNumber)
</success_criteria>

<output>
After completion, create `.planning/phases/23-full-en-fr-language-toggle/23-02-SUMMARY.md`
</output>
