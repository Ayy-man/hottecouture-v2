---
phase: 02-item-level-pricing
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/pricing/calcTotal.ts
  - src/app/api/garment-service/[id]/price/route.ts
autonomous: true

must_haves:
  truths:
    - "calculateItemPrice uses three-tier price hierarchy (final > custom > base)"
    - "PATCH endpoint updates final_price_cents and recalculates order total"
    - "Price changes are logged to price_change_log table"
  artifacts:
    - path: "src/lib/pricing/calcTotal.ts"
      provides: "Updated price calculation with final_price support"
      contains: "final_price_cents"
    - path: "src/app/api/garment-service/[id]/price/route.ts"
      provides: "API endpoint for item price updates"
      exports: ["PATCH"]
  key_links:
    - from: "src/app/api/garment-service/[id]/price/route.ts"
      to: "supabase garment_service table"
      via: "update final_price_cents"
      pattern: "final_price_cents"
    - from: "src/app/api/garment-service/[id]/price/route.ts"
      to: "supabase price_change_log table"
      via: "insert audit log"
      pattern: "price_change_log"
    - from: "src/app/api/garment-service/[id]/price/route.ts"
      to: "supabase order table"
      via: "recalculate totals"
      pattern: "recalculateOrderPricing"
---

<objective>
Implement pricing logic and API endpoint for item-level price updates with audit logging.

Purpose: Enable the backend to handle price changes on individual items, automatically recalculate order totals, and maintain an audit trail.

Output:
- Updated `calculateItemPrice()` function with three-tier price hierarchy
- New API route `PATCH /api/garment-service/[id]/price` for price updates
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-item-level-pricing/02-RESEARCH.md
@.planning/phases/02-item-level-pricing/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update calculateItemPrice with three-tier price hierarchy</name>
  <files>src/lib/pricing/calcTotal.ts</files>
  <action>
Update the `calculateItemPrice` function in `src/lib/pricing/calcTotal.ts` to support the three-tier price hierarchy:

**Current function signature:**
```typescript
export function calculateItemPrice(item: PricingItem): {
  unit_price_cents: number;
  total_price_cents: number;
  is_custom: boolean;
}
```

**Updated function (replace the existing one):**
```typescript
export function calculateItemPrice(item: PricingItem): {
  unit_price_cents: number;
  total_price_cents: number;
  price_source: 'final' | 'custom' | 'base';
  is_custom: boolean;  // Keep for backward compatibility
  is_final: boolean;
} {
  // Priority: final_price > custom_price > base_price
  let unit_price_cents: number;
  let price_source: 'final' | 'custom' | 'base';

  if (item.final_price_cents !== null && item.final_price_cents !== undefined) {
    unit_price_cents = item.final_price_cents;
    price_source = 'final';
  } else if (item.custom_price_cents !== null && item.custom_price_cents !== undefined) {
    unit_price_cents = item.custom_price_cents;
    price_source = 'custom';
  } else {
    unit_price_cents = item.base_price_cents;
    price_source = 'base';
  }

  const total_price_cents = unit_price_cents * item.quantity;

  return {
    unit_price_cents,
    total_price_cents,
    price_source,
    is_custom: price_source === 'custom',  // Backward compatibility
    is_final: price_source === 'final',
  };
}
```

Also update the `calculateOrderPricing` function's item breakdown to include the new fields:
- In the itemBreakdown map, add `price_source` and `is_final` to the returned object
- Update the PricingCalculation type in types.ts if needed to include these new fields in breakdown.items

**Important:** Keep backward compatibility - existing code using `is_custom` should still work.
  </action>
  <verify>
    - `npx tsc --noEmit src/lib/pricing/calcTotal.ts`
    - Verify the function handles all three cases (final, custom, base)
  </verify>
  <done>
    - calculateItemPrice returns price_source indicating which tier was used
    - is_final boolean indicates if final price was used
    - Backward compatible - is_custom still works
    - calculateOrderPricing breakdown includes new fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API endpoint for item price updates</name>
  <files>src/app/api/garment-service/[id]/price/route.ts</files>
  <action>
Create a new API route at `src/app/api/garment-service/[id]/price/route.ts`.

First, create the directory structure if it doesn't exist:
- `src/app/api/garment-service/[id]/price/`

**Implementation based on research document:**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { z } from 'zod';
import { recalculateOrderPricing } from '@/lib/pricing/calcTotal';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

const priceUpdateSchema = z.object({
  new_price_cents: z.number().int().min(0),
  changed_by: z.string().min(1),
  reason: z.string().optional(),
});

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: garmentServiceId } = await params;
    const body = await request.json();
    const { new_price_cents, changed_by, reason } = priceUpdateSchema.parse(body);

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // 1. Get current item with price info and order_id
    const { data: current, error: fetchError } = await supabase
      .from('garment_service')
      .select(`
        id,
        final_price_cents,
        custom_price_cents,
        garment:garment_id (
          order_id
        ),
        service:service_id (
          base_price_cents
        )
      `)
      .eq('id', garmentServiceId)
      .single();

    if (fetchError || !current) {
      return NextResponse.json(
        { error: 'Item not found' },
        { status: 404 }
      );
    }

    const orderId = (current.garment as any).order_id;
    const oldPrice = current.final_price_cents
      ?? current.custom_price_cents
      ?? (current.service as any)?.base_price_cents;

    // 2. Update the final price
    const { error: updateError } = await supabase
      .from('garment_service')
      .update({ final_price_cents: new_price_cents })
      .eq('id', garmentServiceId);

    if (updateError) {
      throw updateError;
    }

    // 3. Log the price change (audit trail)
    const { data: auditLog, error: logError } = await supabase
      .from('price_change_log')
      .insert({
        garment_service_id: garmentServiceId,
        order_id: orderId,
        changed_by,
        old_price_cents: oldPrice,
        new_price_cents: new_price_cents,
        reason: reason || null,
      })
      .select()
      .single();

    if (logError) {
      console.error('Failed to log price change:', logError);
      // Don't fail the request, but log the issue
    }

    // 4. Get all items for this order to recalculate totals
    const { data: allGarments } = await supabase
      .from('garment')
      .select('id')
      .eq('order_id', orderId);

    const garmentIds = (allGarments || []).map(g => g.id);

    const { data: orderItems } = await supabase
      .from('garment_service')
      .select(`
        id,
        garment_id,
        service_id,
        quantity,
        custom_price_cents,
        final_price_cents,
        service:service_id (
          base_price_cents
        )
      `)
      .in('garment_id', garmentIds);

    // 5. Get order rush status
    const { data: order } = await supabase
      .from('order')
      .select('rush, rush_fee_cents')
      .eq('id', orderId)
      .single();

    // 6. Calculate new totals using recalculateOrderPricing
    const items = (orderItems || []).map(item => ({
      garment_id: item.garment_id,
      service_id: item.service_id || '',
      quantity: item.quantity,
      custom_price_cents: item.custom_price_cents,
      final_price_cents: item.final_price_cents,
      base_price_cents: (item.service as any)?.base_price_cents || 0,
    }));

    const totals = recalculateOrderPricing(orderId, items, order?.rush || false);

    // 7. Update order totals in database
    const { data: updatedOrder, error: orderUpdateError } = await supabase
      .from('order')
      .update({
        subtotal_cents: totals.subtotal_cents,
        tax_cents: totals.tax_cents,
        tps_cents: totals.tps_cents,
        tvq_cents: totals.tvq_cents,
        total_cents: totals.total_cents,
      })
      .eq('id', orderId)
      .select()
      .single();

    if (orderUpdateError) {
      throw orderUpdateError;
    }

    return NextResponse.json({
      success: true,
      garment_service: {
        id: garmentServiceId,
        final_price_cents: new_price_cents,
      },
      order: {
        id: orderId,
        subtotal_cents: updatedOrder.subtotal_cents,
        tax_cents: updatedOrder.tax_cents,
        total_cents: updatedOrder.total_cents,
      },
      audit_log_id: auditLog?.id || null,
    });

  } catch (error) {
    console.error('Error updating price:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data', details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to update price' },
      { status: 500 }
    );
  }
}
```

**Key behaviors:**
1. Validates input with Zod
2. Fetches current price for audit logging
3. Updates final_price_cents on garment_service
4. Logs change to price_change_log table
5. Recalculates order totals using existing pricing functions
6. Updates order table with new totals
7. Returns updated prices and audit log ID
  </action>
  <verify>
    - File exists at correct path: `ls src/app/api/garment-service/[id]/price/route.ts`
    - TypeScript compiles: `npx tsc --noEmit src/app/api/garment-service/[id]/price/route.ts`
  </verify>
  <done>
    - PATCH endpoint created at /api/garment-service/[id]/price
    - Validates input (new_price_cents, changed_by, optional reason)
    - Updates final_price_cents column
    - Logs to price_change_log with old/new values
    - Recalculates and updates order totals
    - Returns success response with updated values
  </done>
</task>

</tasks>

<verification>
1. `calculateItemPrice()` handles final_price_cents as highest priority
2. API route exists and compiles without errors
3. API route includes audit logging
4. API route recalculates order totals after price change
</verification>

<success_criteria>
- Price calculation uses three-tier hierarchy: final > custom > base
- API endpoint accepts price updates with audit info
- Price changes automatically recalculate order totals
- All price changes logged with who/when/old/new values
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-item-level-pricing/02-02-SUMMARY.md`
</output>
