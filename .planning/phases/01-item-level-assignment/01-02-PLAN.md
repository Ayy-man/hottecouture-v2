---
phase: 01-item-level-assignment
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/types/database.ts
  - src/lib/board/types.ts
  - src/app/api/garment-service/[id]/assign/route.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript types include assigned_seamstress_id field"
    - "API endpoint exists to assign seamstress to specific item"
    - "Assignment change persists to database"
  artifacts:
    - path: "src/lib/types/database.ts"
      provides: "Type definition for assigned_seamstress_id"
      contains: "assigned_seamstress_id"
    - path: "src/lib/board/types.ts"
      provides: "BoardOrder type with assignment info"
      contains: "assigned_seamstress_id"
    - path: "src/app/api/garment-service/[id]/assign/route.ts"
      provides: "PATCH endpoint to assign seamstress"
      exports: ["PATCH"]
  key_links:
    - from: "src/app/api/garment-service/[id]/assign/route.ts"
      to: "garment_service.assigned_seamstress_id"
      via: "Supabase update query"
      pattern: "update.*assigned_seamstress_id"
---

<objective>
Add TypeScript types and API endpoint for item-level assignment.

Purpose: Enable the frontend to assign seamstresses to individual items with proper type safety and a dedicated API endpoint.

Output: Updated TypeScript types and a new PATCH endpoint for item assignment.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-item-level-assignment/01-01-SUMMARY.md

# Key files to understand current patterns:
@src/lib/types/database.ts
@src/lib/board/types.ts
@src/app/api/order/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update TypeScript types for item-level assignment</name>
  <files>src/lib/types/database.ts, src/lib/board/types.ts</files>
  <action>
Update TypeScript types to include the new assignment fields:

**In `src/lib/types/database.ts`:**

1. Add to `garment_service.Row`:
```typescript
assigned_seamstress_id: string | null;
```

2. Add to `garment_service.Insert`:
```typescript
assigned_seamstress_id?: string | null;
```

3. Add to `garment_service.Update`:
```typescript
assigned_seamstress_id?: string | null;
```

4. Add `staff` table types if not present:
```typescript
staff: {
  Row: {
    id: string;
    name: string;
    is_active: boolean;
    created_at: string;
  };
  Insert: {
    id?: string;
    name: string;
    is_active?: boolean;
    created_at?: string;
  };
  Update: {
    id?: string;
    name?: string;
    is_active?: boolean;
    created_at?: string;
  };
};
```

**In `src/lib/board/types.ts`:**

5. Update the `BoardOrder.garments[].services[]` type to include:
```typescript
assigned_seamstress_id?: string | null;
assigned_seamstress_name?: string | null;
```

6. Update `BoardFilters` to use `assignedSeamstressId` instead of string name (optional - can keep both for transition).

IMPORTANT: Do not change existing field types - only add new fields. This ensures backward compatibility.
  </action>
  <verify>
Run TypeScript compiler to check for type errors:
```bash
cd /Users/aymanbaig/Desktop/hottecouture-main && npx tsc --noEmit
```
Expected: No type errors related to the changes.
  </verify>
  <done>
    - `garment_service` types include `assigned_seamstress_id`
    - `staff` table types exist in database.ts
    - `BoardOrder` interface includes assignment fields in services
    - TypeScript compilation succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API endpoint for item assignment</name>
  <files>src/app/api/garment-service/[id]/assign/route.ts</files>
  <action>
Create a new PATCH endpoint to assign a seamstress to a specific garment_service:

**File: `src/app/api/garment-service/[id]/assign/route.ts`**

Endpoint behavior:
- Method: PATCH
- URL: `/api/garment-service/{garment_service_id}/assign`
- Body: `{ "seamstress_id": "uuid-string" | null }`
- Response: `{ "success": true, "data": { updated garment_service } }` or error

Implementation steps:
1. Import Supabase server client from `@/lib/supabase/server`
2. Validate request body with Zod:
   - `seamstress_id`: string (UUID) or null (to unassign)
3. If `seamstress_id` provided, verify it exists in staff table
4. Update `garment_service.assigned_seamstress_id` where `id = params.id`
5. Return updated record

Error handling:
- 400: Invalid body or UUID format
- 404: garment_service or staff not found
- 500: Database error

Follow the existing API patterns in `src/app/api/order/[id]/route.ts`.

IMPORTANT: Use `createClient` from `@/lib/supabase/server` for server-side operations.
  </action>
  <verify>
Test with curl:
```bash
# Get a garment_service ID and staff ID first
# Then test the endpoint:

# Assign:
curl -X PATCH http://localhost:3000/api/garment-service/GARMENT_SERVICE_ID/assign \
  -H "Content-Type: application/json" \
  -d '{"seamstress_id": "STAFF_UUID"}'

# Unassign:
curl -X PATCH http://localhost:3000/api/garment-service/GARMENT_SERVICE_ID/assign \
  -H "Content-Type: application/json" \
  -d '{"seamstress_id": null}'
```
Expected: 200 response with updated garment_service data.
  </verify>
  <done>
    - PATCH endpoint exists at `/api/garment-service/[id]/assign`
    - Can assign seamstress by UUID
    - Can unassign by passing null
    - Validates staff existence before assignment
    - Returns updated record on success
  </done>
</task>

<task type="auto">
  <name>Task 3: Add staff fetch utility hook</name>
  <files>src/lib/hooks/useStaff.ts</files>
  <action>
Create a reusable hook to fetch active staff members:

**File: `src/lib/hooks/useStaff.ts`**

```typescript
'use client'

import { useState, useEffect } from 'react'
import { createClient } from '@/lib/supabase/client'

interface Staff {
  id: string
  name: string
  is_active: boolean
}

export function useStaff() {
  const [staff, setStaff] = useState<Staff[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchStaff = async () => {
      const supabase = createClient()
      const { data, error } = await supabase
        .from('staff')
        .select('id, name, is_active')
        .eq('is_active', true)
        .order('name')

      if (error) {
        setError(error.message)
      } else {
        setStaff(data || [])
      }
      setLoading(false)
    }

    fetchStaff()
  }, [])

  return { staff, loading, error }
}
```

This hook will be used by:
- Assignment dropdown components
- Board filters
- Any UI that needs to show seamstress options

IMPORTANT: Only fetch active staff (is_active = true).
  </action>
  <verify>
Create a simple test component or use React DevTools to verify:
1. Hook fetches staff on mount
2. Returns array of staff with id, name, is_active
3. Only active staff are returned
4. Error state works when Supabase unavailable
  </verify>
  <done>
    - `useStaff` hook exists at `src/lib/hooks/useStaff.ts`
    - Returns staff array with id, name, is_active
    - Filters to active staff only
    - Handles loading and error states
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Type checking:
```bash
npx tsc --noEmit
```

2. API endpoint test:
```bash
# Start dev server
npm run dev

# In another terminal, test the endpoint
curl -X PATCH http://localhost:3000/api/garment-service/test-id/assign \
  -H "Content-Type: application/json" \
  -d '{"seamstress_id": null}'
# Should return 404 for non-existent ID (correct error handling)
```

3. Verify types are correct by checking IDE autocomplete:
- Open `src/lib/board/types.ts`
- `BoardOrder.garments[0].services[0].` should show `assigned_seamstress_id` in autocomplete
</verification>

<success_criteria>
1. TypeScript compiles without errors
2. `garment_service` types include `assigned_seamstress_id`
3. `staff` table types exist
4. PATCH `/api/garment-service/[id]/assign` endpoint works
5. `useStaff` hook fetches active staff
</success_criteria>

<output>
After completion, create `.planning/phases/01-item-level-assignment/01-02-SUMMARY.md`
</output>
