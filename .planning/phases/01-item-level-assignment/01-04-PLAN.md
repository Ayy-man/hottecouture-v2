---
phase: 01-item-level-assignment
plan: 04
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/components/intake/assignment-step.tsx
  - src/app/api/intake/route.ts
  - src/components/board/order-card.tsx
autonomous: true

must_haves:
  truths:
    - "Can assign different seamstresses to different items during intake"
    - "Order creation saves assigned_seamstress_id per garment_service"
    - "Order cards show item-level assignees (not just order-level)"
  artifacts:
    - path: "src/components/intake/assignment-step.tsx"
      provides: "Per-item seamstress assignment UI"
      contains: "assigned_seamstress_id"
    - path: "src/app/api/intake/route.ts"
      provides: "Saves seamstress assignment per garment_service"
      contains: "assigned_seamstress_id"
    - path: "src/components/board/order-card.tsx"
      provides: "Displays item-level assignees"
      contains: "assigned_seamstress"
  key_links:
    - from: "src/components/intake/assignment-step.tsx"
      to: "garment_service"
      via: "Assignment data passed to intake API"
      pattern: "assigned_seamstress_id|assignedTo"
    - from: "src/app/api/intake/route.ts"
      to: "garment_service.assigned_seamstress_id"
      via: "Supabase insert"
      pattern: "assigned_seamstress_id.*insert|insert.*assigned_seamstress_id"
---

<objective>
Update intake flow and order cards to support item-level assignment.

Purpose: Enable seamstresses to assign different team members to different items during order creation, and display these assignments clearly on order cards.

Output: Updated intake components and API that create orders with per-item assignment, plus order cards that show item-level assignees.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-item-level-assignment/01-02-SUMMARY.md

# Key files to modify:
@src/components/intake/assignment-step.tsx
@src/app/api/intake/route.ts
@src/components/board/order-card.tsx

# Reference for patterns:
@src/lib/hooks/useStaff.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update assignment-step.tsx for per-item assignment</name>
  <files>src/components/intake/assignment-step.tsx</files>
  <action>
Refactor the assignment step to allow assigning seamstresses to individual items (garment + services) instead of the entire order.

**Current behavior:** Single seamstress selection for entire order
**New behavior:** Seamstress dropdown per item (garment_service)

**Changes to make:**

1. Update props interface to receive items list:
```typescript
interface AssignmentStepProps {
  // Remove: selectedAssignee: string | null;
  // Remove: onAssigneeChange: (assignee: string) => void;

  // Add: items with their assignments
  items: Array<{
    garmentIndex: number;
    garmentType: string;
    serviceIndex: number;
    serviceName: string;
    assignedSeamstressId: string | null;
  }>;
  onItemAssignmentChange: (garmentIndex: number, serviceIndex: number, seamstressId: string | null) => void;

  // Keep existing:
  onNext: () => void;
  onPrev: () => void;
  isSubmitting?: boolean;
}
```

2. Display a list of items with dropdown per item:
```tsx
{items.map((item, idx) => (
  <Card key={`${item.garmentIndex}-${item.serviceIndex}`}>
    <CardContent className="p-4">
      <div className="flex items-center justify-between">
        <div>
          <p className="font-medium">{item.garmentType}</p>
          <p className="text-sm text-muted-foreground">{item.serviceName}</p>
        </div>
        <Select
          value={item.assignedSeamstressId || ''}
          onValueChange={(val) => onItemAssignmentChange(
            item.garmentIndex,
            item.serviceIndex,
            val || null
          )}
        >
          <SelectTrigger className="w-40">
            <SelectValue placeholder="Unassigned" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="">Unassigned</SelectItem>
            {staff.map(s => (
              <SelectItem key={s.id} value={s.id}>{s.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
    </CardContent>
  </Card>
))}
```

3. Add "Assign All" quick action to assign all items to same seamstress:
```tsx
<div className="mb-4">
  <Select onValueChange={(val) => {
    items.forEach(item => {
      onItemAssignmentChange(item.garmentIndex, item.serviceIndex, val || null);
    });
  }}>
    <SelectTrigger>
      <SelectValue placeholder="Assign all to..." />
    </SelectTrigger>
    <SelectContent>
      {staff.map(s => (
        <SelectItem key={s.id} value={s.id}>{s.name}</SelectItem>
      ))}
    </SelectContent>
  </Select>
</div>
```

4. Allow proceeding even if some items are unassigned (items can be assigned later)

5. Update header text from "Assigner la commande" to "Assigner les taches" (Assign tasks)

IMPORTANT:
- Import Select components from @/components/ui/select
- Use useStaff() hook for staff list
- Keep bilingual labels (French UI)
  </action>
  <verify>
1. Start dev server and navigate to intake flow
2. Add garments with services
3. Reach assignment step
4. Verify:
   - Each item shows separately with its own dropdown
   - Can assign different seamstresses to different items
   - "Assign All" quick action works
   - Can proceed with some items unassigned
  </verify>
  <done>
    - Assignment step shows list of items
    - Each item has its own seamstress dropdown
    - "Assign All" quick action exists
    - Can assign different seamstresses to different items
  </done>
</task>

<task type="auto">
  <name>Task 2: Update intake API to save per-item assignments</name>
  <files>src/app/api/intake/route.ts</files>
  <action>
Update the intake API to save `assigned_seamstress_id` for each garment_service during order creation.

**Changes to make:**

1. Update expected request body schema to accept assignment per service:
```typescript
// In garments array, each service should have optional assignedSeamstressId
garments: Array<{
  type: string;
  garment_type_id?: string;
  services: Array<{
    serviceId: string;
    qty: number;
    customPriceCents?: number;
    notes?: string;
    assignedSeamstressId?: string; // NEW: UUID of assigned seamstress
  }>;
}>;
```

2. When inserting garment_service records, include assigned_seamstress_id:

**For regular services (around line 437):**
```typescript
const { error: garmentServiceError } = await supabase
  .from('garment_service')
  .insert({
    garment_id: (newGarment as any).id,
    service_id: serviceId,
    quantity: service.qty || 1,
    custom_price_cents: service.customPriceCents || null,
    notes: service.notes || null,
    estimated_minutes: estimatedMinutes,
    assigned_seamstress_id: service.assignedSeamstressId || null, // NEW
  } as any);
```

**For custom services (around line 374):**
```typescript
const { error: garmentServiceError } = await supabase
  .from('garment_service')
  .insert({
    garment_id: (newGarment as any).id,
    service_id: (newCustomService as any).id,
    quantity: service.qty || 1,
    custom_price_cents: service.customPriceCents || null,
    notes: service.notes || null,
    estimated_minutes: customEstimatedMinutes,
    assigned_seamstress_id: service.assignedSeamstressId || null, // NEW
  } as any);
```

3. Remove or deprecate the order-level `assigned_to` handling:
   - Keep setting `order.assigned_to` for backward compatibility (use first item's assignment if any)
   - Add comment marking it as deprecated

4. Update calendar webhook call to handle item-level assignment:
   - If multiple seamstresses assigned, create calendar event for each OR
   - Use first assigned seamstress for the calendar event (simpler)

IMPORTANT:
- Do NOT validate that assignedSeamstressId exists in staff table (frontend handles this)
- NULL is valid (unassigned items)
- Keep all existing error handling intact
  </action>
  <verify>
1. Create a test order with items assigned to different seamstresses:
```bash
curl -X POST http://localhost:3000/api/intake \
  -H "Content-Type: application/json" \
  -d '{
    "client": {"first_name": "Test", "last_name": "Client", "phone": "555-1234"},
    "order": {"type": "alteration"},
    "garments": [{
      "type": "Pants",
      "services": [
        {"serviceId": "SERVICE_UUID_1", "qty": 1, "assignedSeamstressId": "STAFF_UUID_A"},
        {"serviceId": "SERVICE_UUID_2", "qty": 1, "assignedSeamstressId": "STAFF_UUID_B"}
      ]
    }]
  }'
```

2. Query the database to verify assignments:
```sql
SELECT gs.id, gs.assigned_seamstress_id, s.name as service_name
FROM garment_service gs
JOIN service s ON s.id = gs.service_id
WHERE gs.garment_id IN (
  SELECT id FROM garment WHERE order_id = 'NEW_ORDER_ID'
);
```
Expected: Different assigned_seamstress_id values for different services
  </verify>
  <done>
    - Intake API accepts assignedSeamstressId per service
    - garment_service records are created with assigned_seamstress_id
    - Different items can have different seamstresses
    - Order creation succeeds with mixed/no assignments
  </done>
</task>

<task type="auto">
  <name>Task 3: Update order-card to show item-level assignees</name>
  <files>src/components/board/order-card.tsx</files>
  <action>
Update the order card component to display item-level assignments instead of showing all assignees in a single line.

**Current behavior:** Shows "Assignee: Anne-Marie, Audrey" (aggregated from tasks)
**New behavior:** Shows each item with its assignee OR shows breakdown by assignee

**Changes to make:**

1. Update assignees extraction to use item-level assignment:
```typescript
// OLD: const assignees = Array.from(new Set(order.tasks.map(t => t.assignee).filter(Boolean)));

// NEW: Extract item-level assignments
const itemAssignments = order.garments
  .flatMap(g => (g.services || []).map(s => ({
    garmentType: g.type,
    serviceName: s.service?.name || s.custom_service_name || 'Service',
    assigneeName: s.assigned_seamstress_name,
    assigneeId: s.assigned_seamstress_id
  })))
  .filter(item => item.assigneeName);

// Group by assignee for display
const assigneeGroups = itemAssignments.reduce((acc, item) => {
  const name = item.assigneeName!;
  if (!acc[name]) acc[name] = [];
  acc[name].push(item);
  return acc;
}, {} as Record<string, typeof itemAssignments>);

const uniqueAssignees = Object.keys(assigneeGroups);
const hasUnassigned = order.garments
  .flatMap(g => g.services || [])
  .some(s => !s.assigned_seamstress_id);
```

2. Update the assignees display section:
```tsx
{/* Item Assignments */}
{uniqueAssignees.length > 0 && (
  <div className='mb-3'>
    <p className='text-sm font-medium text-muted-foreground mb-1'>Assigned:</p>
    <div className='space-y-1'>
      {uniqueAssignees.map(name => (
        <div key={name} className='flex items-center text-sm'>
          <span className='w-2 h-2 rounded-full bg-primary mr-2' />
          <span className='font-medium'>{name}</span>
          <span className='text-muted-foreground ml-1'>
            ({assigneeGroups[name].length} item{assigneeGroups[name].length > 1 ? 's' : ''})
          </span>
        </div>
      ))}
      {hasUnassigned && (
        <div className='flex items-center text-sm text-amber-600'>
          <span className='w-2 h-2 rounded-full bg-amber-400 mr-2' />
          <span>Some items unassigned</span>
        </div>
      )}
    </div>
  </div>
)}

{/* Show unassigned warning if no assignees at all */}
{uniqueAssignees.length === 0 && (
  <div className='mb-3'>
    <p className='text-sm text-amber-600'>
      <span className='font-medium'>Unassigned</span>
    </p>
  </div>
)}
```

3. Update the "Assign to Me" button logic:
```typescript
// Only show if there are unassigned items AND onAssign is provided
{hasUnassigned && onAssign && (
  <Button
    size='sm'
    variant='outline'
    className='flex-1 text-xs'
    disabled={isUpdating}
    onClick={() => onAssign(order.id)}
  >
    Assign to Me
  </Button>
)}
```

4. Ensure the BoardOrder type includes the necessary fields (should already be done in Plan 02):
   - `services[].assigned_seamstress_id`
   - `services[].assigned_seamstress_name`

IMPORTANT: Keep the existing card layout and styling. Only change the assignee display logic.
  </action>
  <verify>
1. Open board view with orders that have item-level assignments
2. Verify order cards show:
   - Assignee name with item count (e.g., "Anne-Marie (2 items)")
   - Multiple assignees if items assigned to different people
   - "Some items unassigned" warning if applicable
   - "Unassigned" label if no assignments at all
3. Verify "Assign to Me" button appears only when there are unassigned items
  </verify>
  <done>
    - Order cards show item-level assignees
    - Assignees grouped with item count
    - Unassigned items clearly indicated
    - "Assign to Me" button only shows when items are unassigned
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the complete intake-to-display flow:

1. **Create order with mixed assignments:**
   - Start new order intake
   - Add 2 garments, each with 1-2 services
   - On assignment step, assign Item 1 to Seamstress A, Item 2 to Seamstress B, leave Item 3 unassigned
   - Complete order creation

2. **Verify database records:**
```sql
SELECT gs.id, gs.assigned_seamstress_id, s.name as assigned_to
FROM garment_service gs
LEFT JOIN staff s ON s.id = gs.assigned_seamstress_id
WHERE gs.garment_id IN (
  SELECT id FROM garment WHERE order_id = 'NEW_ORDER_ID'
);
```
Expected: Different assigned_seamstress_id values

3. **Verify order card display:**
   - Navigate to board
   - Find the new order
   - Verify card shows:
     - "Seamstress A (1 item)"
     - "Seamstress B (1 item)"
     - "Some items unassigned"

4. **Verify workload page (from Plan 03):**
   - Navigate to workload view
   - Item 1 appears under Seamstress A
   - Item 2 appears under Seamstress B
   - Item 3 appears under "Unassigned"
</verification>

<success_criteria>
1. Assignment step allows per-item seamstress selection
2. Intake API saves assigned_seamstress_id per garment_service
3. Order cards show item-level assignee breakdown
4. Can create order with items assigned to different seamstresses
5. Unassigned items are clearly visible
6. Existing orders continue to work (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/01-item-level-assignment/01-04-SUMMARY.md`
</output>
