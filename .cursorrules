# Hotte Couture - Codebase Documentation

## Project Overview
This is a Next.js 14.2.33 application for a tailoring/alteration business management system. The app handles order intake, client management, Kanban board workflow, and pricing calculations.

## Tech Stack
- **Framework**: Next.js 14.2.33 (App Router)
- **Language**: TypeScript
- **Database**: Supabase (PostgreSQL)
- **Styling**: Tailwind CSS
- **Deployment**: Vercel
- **Package Manager**: npm

## Project Structure

### Key Directories
- `src/app/` - Next.js App Router pages and API routes
- `src/components/` - React components organized by feature
- `src/lib/` - Utility functions, types, and business logic
- `supabase/migrations/` - Database migration files
- `locales/` - Internationalization files (en.json, fr.json)

### Important Files
- `src/lib/types/database.ts` - Supabase database type definitions (CRITICAL: Keep in sync with actual schema)
- `src/lib/supabase/server.ts` - Server-side Supabase client creation
- `src/lib/supabase/client.ts` - Client-side Supabase client creation
- `src/middleware.ts` - Next.js middleware for auth/routing

## Architecture Patterns

### 1. API Routes (`src/app/api/`)
All API routes use:
- `createServiceRoleClient()` for admin operations (bypasses RLS)
- `createClient()` for user operations (respects RLS)
- Type assertions `as any` for Supabase queries (workaround for TypeScript inference issues)
- Route segment config: `export const dynamic = 'force-dynamic'` and `export const revalidate = 0` to disable caching

**Example Pattern:**
```typescript
export const dynamic = 'force-dynamic';
export const revalidate = 0;

export async function GET() {
  const supabase = await createServiceRoleClient();
  const { data, error } = await (supabase.from('table') as any)
    .select('*')
    .eq('is_active', true);
  
  return NextResponse.json(
    { data },
    {
      headers: {
        'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
        Pragma: 'no-cache',
        Expires: '0',
      },
    }
  );
}
```

### 2. Client Components
- All intake form components are client components (`'use client'`)
- State management uses React hooks (`useState`, `useEffect`, `useMemo`)
- CRUD operations update state directly from API responses (no refetching to avoid caching issues)

**Critical Pattern for CRUD:**
```typescript
// ✅ CORRECT: Update state directly
if (result.item) {
  setItems(prevItems => 
    prevItems.map(item => item.id === id ? result.item : item)
  );
}

// ❌ WRONG: Don't refetch (causes caching issues in production)
await loadItems();
```

### 3. Caching Strategy
**CRITICAL**: Production caching issues have been a major problem. Always:

1. **API Routes**: Add cache-control headers and route segment config
2. **Client Fetch**: Use `cache: 'no-store'` and cache-control headers
3. **State Updates**: Update state directly from API responses, don't refetch

**Example:**
```typescript
const response = await fetch('/api/items', {
  cache: 'no-store',
  headers: {
    'Cache-Control': 'no-cache, no-store, must-revalidate',
    Pragma: 'no-cache',
  },
});
```

## Database Schema

### Key Tables
- `order` - Main order records
- `client` - Client information
- `garment` - Garments in orders (has `garment_type_id` foreign key)
- `garment_type` - Types of garments (id, code, name, category, icon, is_common, is_active, is_custom)
- `garment_service` - Services applied to garments (has `id`, nullable `service_id`, `custom_service_name`)
- `service` - Available services (has `display_order`, `is_active`, `unit` for unit-based pricing)
- `category` - Service categories (id, key, name, icon, display_order, is_active)

### Important Notes
- `garment_type_id` in `garment` table can be `null`
- `service_id` in `garment_service` can be `null` (for custom services)
- All tables use soft deletes (`is_active = false`) instead of hard deletes
- `display_order` is used for sorting within categories

## Intake Form Flow

### Steps (in order):
1. **Pipeline Selection** - Choose 'alteration' or 'custom design'
2. **Client Step** - Client information (phone required)
3. **Garments Step** - Add garments with types (CRUD for garment types)
4. **Services Step** - Select services per garment (CRUD for categories and services)
5. **Notes Step** - Measurements and special instructions
6. **Pricing Step** - Review pricing and due date
7. **Summary** - Final review before submission

### Key Components
- `src/components/intake/garments-step.tsx` - Garment selection with garment type CRUD
- `src/components/intake/services-step-new.tsx` - Service selection with category/service CRUD
- `src/app/intake/page.tsx` - Main intake form orchestrator

## CRUD Operations Pattern

### For Categories, Services, and Garment Types:

1. **Create**: Add to state directly, sort alphabetically
2. **Update**: Update specific item in state using `map()`
3. **Delete**: Remove from state using `filter()`
4. **Always update both**: If using grouped data (like `groupedTypes`), update both the flat array and grouped object

**Example for Garment Types:**
```typescript
// Update both garmentTypes and groupedTypes
setGarmentTypes(prevTypes =>
  prevTypes.map(type => type.id === id ? updatedType : type)
);

setGroupedTypes(prevGrouped => {
  const newGrouped = { ...prevGrouped };
  Object.keys(newGrouped).forEach(category => {
    newGrouped[category] = newGrouped[category]!.map(type =>
      type.id === id ? updatedType : type
    );
  });
  return newGrouped;
});
```

## Special Features

### 1. Zip Selection Modal
When certain services are selected (those containing "zip"), a modal appears to select a "Zip séparable" option. Triggered services:
- Changer zip d'une veste ou chandail
- Changer zip de jeans
- Changer zip de manteau + zip
- Changer zip de manteau + zip (manteau long)
- Changer zip de manteau scellé + zip

### 2. Unit-Based Pricing
Services can have a `unit` field (e.g., "prix", "yard"). Display format: `$10.00/unit` or just `$10.00` if no unit.

### 3. Pipeline-Based Filtering
- **Alteration**: Hides "Curtains" and "Custom" categories
- **Custom Design**: Shows all categories

### 4. Alphabetical Sorting
- Categories sorted alphabetically by name
- Services within each category sorted alphabetically
- Garment types sorted by category, then is_common, then name

## TypeScript Type Definitions

### Critical File: `src/lib/types/database.ts`
This file MUST be kept in sync with the actual Supabase schema. Currently includes:
- All table definitions with Row, Insert, Update types
- `garment_type` table (was missing, added)
- `category` table (was missing, added)
- `garment_type_id` in `garment` table
- `id`, nullable `service_id`, `custom_service_name` in `garment_service` table

**If adding new tables/columns:**
1. Update `src/lib/types/database.ts` first
2. Use type assertions `as any` if TypeScript inference fails
3. This is a known workaround for Supabase type inference issues

## Known Issues & Fixes

### 1. TypeScript Type Inference
**Problem**: Supabase PostgrestFilterBuilder type inference fails for some tables
**Solution**: Use `as any` type assertions on `.from('table')` queries
**Files**: All API routes in `src/app/api/admin/`

### 2. Production Caching
**Problem**: Next.js/Vercel caches API responses, causing stale data
**Solution**: 
- Add `dynamic = 'force-dynamic'` and `revalidate = 0` to API routes
- Add cache-control headers to responses
- Use `cache: 'no-store'` in fetch calls
- Update state directly instead of refetching

### 3. State Synchronization
**Problem**: Refetching after CRUD operations causes race conditions
**Solution**: Update state directly from API response data

## Deployment Process

1. **Build Check**: Always run `npm run build` locally first
2. **Commit**: Use descriptive commit messages
3. **Push**: `git push origin main`
4. **Deploy**: `npx vercel --prod`

**Important**: Check for TypeScript errors before deploying. Common issues:
- Unused variables
- Missing type definitions
- Type mismatches

## Code Style & Conventions

- **Components**: Use functional components with hooks
- **Naming**: PascalCase for components, camelCase for functions/variables
- **Error Handling**: Always use try/catch with user-friendly alerts
- **Loading States**: Show loading indicators during async operations
- **Form Validation**: Validate on submit, show clear error messages
- **Accessibility**: Use semantic HTML, proper labels, min-h-[44px] for touch targets

## Testing Checklist

Before deploying:
- [ ] TypeScript compiles without errors
- [ ] CRUD operations update UI immediately
- [ ] No console errors in browser
- [ ] Works in both local and production
- [ ] Hard refresh (Cmd+Shift+R) shows latest data
- [ ] All form validations work
- [ ] Error messages are user-friendly

## Important Reminders

1. **Never refetch after CRUD** - Always update state directly
2. **Always add cache-busting** - For all API calls in production
3. **Keep database types in sync** - Update `database.ts` when schema changes
4. **Use service role client for admin** - Bypasses RLS for admin operations
5. **Soft deletes only** - Set `is_active = false`, never hard delete
6. **Check usage before delete** - Prevent deleting items in use

## Future Considerations

- Consider implementing optimistic updates for better UX
- May need to add real-time subscriptions for multi-user scenarios
- Consider adding undo/redo for CRUD operations
- May need pagination for large lists
- Consider adding search/filter UI for better UX

